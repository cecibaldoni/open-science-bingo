<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Open Science Bingo</title>
<link rel="stylesheet" href="style.css" />

</head>
<body>
<header>Open Science Bingo</header>

<div id="modeToggle">
  <button id="btnPlayer" disabled>Player Mode</button>
  <button id="btnHost">Host Mode</button>
</div>

<div id="container">
  <div id="playerPanel">
    <div id="markerSelect" aria-label="Select marker">
      <span class="marker-option selected" data-marker="check">âœ“</span>
      <span class="marker-option" data-marker="cross">âœ—</span>
      <span class="marker-option" data-marker="heart">â™¥</span>
      <span class="marker-option" data-marker="star">â˜…</span>
    </div>
    <div id="bingoCard" role="grid" aria-label="Bingo Card"></div>
    <div style="text-align:center; margin-top:1rem;">
      <button id="btnClear">Clear Card</button>
      <button id="btnNew">New Card</button>
    </div>
  </div>

  <div id="hostPanel" style="display:none;">
    <button id="btnSpin">ðŸŽ² Spin the Wheel!</button>
    <div id="calledStatement" aria-live="polite"></div>
    <h4>Called Statements History</h4>
    <ul id="historyList" aria-live="polite" aria-label="History of called statements"></ul>
    <button id="btnResetGame" style="margin-top:1rem;">Start a New Game!</button>
  </div>
</div>

<script>
  // Statements for the bingo card and wheel
  const statements = [
  // Code/Models
  "Preregistered before the data tempted me",
  "Defined statistical models a priori",
  "Defined hypotheses & predictions a priori",
  "Performed power analysis / model verification",
  "Clearly annotated code (Future me was grateful)",
  "Actually used git (no more Final_v3.R)",
  "Ran my analysis on a colleague's computer (and it worked!)",
  "Used seed numbers for reproducibility",
  "Documented my computational environment (e.g. Docker/conda/renv)",
  "Included a detailed README file",
  "Started using computational notebooks (e.g. Quarto, Jupyter)",
  "Provided summary statistics in supplemental material",
  "Received a compliment on OS aspect of my data or code",
  "Reviewed data or code",
  "Used open source tools (e.g. R, Python)",
  "Cited main code packages used in analysis in a paper/chapter",
  "Cited Open Source statistical software (Software deserves credit too)",
  "Adhered to the 4Râ€™s (Reported, Run, Reproducible, Reliable)",

  // Publishing
  "Reviewed someone elseâ€™s manuscript",
  "Cited software, including the version used",
  "Followed a reporting guideline (e.g., STROBE, ARRIVE, CONSORT)",
  "Shared data on repositories as interoperable files (FAIR data applied)",
  "Published in a preprint server (e.g. EcoEvorXiv, BiorXiv)",
  "Made my protocol public (Before the experiment started)",
  "Wrote a Data Management Plan",
  "Published in Open Access journals",
  "Used DOIs and persistent identifiers",
  "Listed my funding!",
  "Disclosed conflicts of interest (Transparency rocked)",
  "Shared raw data alongside my processed data",
  "Reviewed a preprint",
  "Created a CITATION file (Help people cite my code)",
  "Included a license in my data repository",
  "Included a license in my code repository",
  "Added an ethics statement in my manuscript",
  "Was kind in the acknowledgements (Science is not done alone! :)",
  "Provided metadata to my data",
  "Published that null result!",

  // SORTEE
  "Participated in the SORTEE Conference!",
  "Participated in at least one SORTEE Virtual Social",
  "Participated in at least one SORTEE Code Club",
  "Joined the SORTEE Slack community",
  "Joined the SORTEE Code Club Slack channel #code_club",
  "Joined the SORTEE Social Slack channel #sortee-social",
  "Joined a SORTEE Committee (past or future!)",
  "Joined a SORTEE Hackathon!",
  "Joined a SORTEE seminar",
  "Submitted a code club topic suggestion (I helped lead the learning)",
  "Pitched SORTEE to lab members",

  // Training
  "Started a local hacky hour/code club",
  "Gave a talk on Open Science",
  "Participated in an Open Science workshop/lecture",
  "Participated in a discussion about inclusivity in science (DEI)",
  "Contributed to building a diverse research team",
  "Helped somebody with Open Science practices (Pay it forward)"
];
  // Globals
  let cardStatements = [];
  let calledStatements = [];
  let selectedMarker = 'check';
  let mode = "player"; // or "host"
  let cardState = Array(25).fill(false); // marked or not

  // DOM references
  const bingoCardEl = document.getElementById('bingoCard');
  const markerOptions = document.querySelectorAll('.marker-option');
  const btnClear = document.getElementById('btnClear');
  const btnNew = document.getElementById('btnNew');
  const btnSpin = document.getElementById('btnSpin');
  const calledStatementEl = document.getElementById('calledStatement');
  const historyListEl = document.getElementById('historyList');
  const btnResetGame = document.getElementById('btnResetGame');
  const btnPlayer = document.getElementById('btnPlayer');
  const btnHost = document.getElementById('btnHost');
  const playerPanel = document.getElementById('playerPanel');
  const hostPanel = document.getElementById('hostPanel');

  // Helpers
  function shuffle(array) {
    let arr = array.slice();
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Generate card with random unique statements (except free center)
  function generateCard() {
    let shuffled = shuffle(statements);
    cardStatements = shuffled.slice(0, 24);
    // Insert free space in center (index 12)
    cardStatements.splice(12, 0, "FREE");
    cardState = Array(25).fill(false);
    renderCard();
  }

  // Render bingo card cells
  function renderCard() {
    bingoCardEl.innerHTML = '';
    cardStatements.forEach((statement, i) => {
      const cell = document.createElement('div');
      cell.className = 'cell';
      if (i === 12) {
        cell.classList.add('free-space');
        cell.textContent = ''; // will place logo later, "FREE" placeholder for now
        // For now just text:
        cell.textContent = "FREE";
      } else {
        cell.textContent = statement;
        cell.setAttribute('tabindex', 0);
        cell.addEventListener('click', () => toggleMark(i));
        cell.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            toggleMark(i);
          }
        });
      }
      // Mark if already marked
      if (cardState[i]) {
        cell.classList.add('marked');
        cell.style.color = getMarkerColor(selectedMarker);
        cell.textContent = getMarkerSymbol(selectedMarker);
      }
      bingoCardEl.appendChild(cell);
    });
  }

  // Marker symbols by type
  function getMarkerSymbol(marker) {
    switch(marker){
      case 'check': return 'âœ“';
      case 'cross': return 'âœ—';
      case 'heart': return 'â™¥';
      case 'star': return 'â˜…'; // Placeholder for SORTEE logo symbol
      default: return '';
    }
  }
  // Marker colors by type
  function getMarkerColor(marker) {
    switch(marker){
      case 'check': return 'var(--marker-green)';
      case 'cross': return 'var(--marker-red)';
      case 'heart': return 'var(--red)';
      case 'star': return 'gold';
      default: return 'black';
    }
  }

  // Toggle mark on card cell
  function toggleMark(index) {
    if (index === 12) return; // can't mark free space
    cardState[index] = !cardState[index];
    renderCard();
  }

  // Marker selection logic
  markerOptions.forEach(opt => {
    opt.addEventListener('click', () => {
      markerOptions.forEach(o=>o.classList.remove('selected'));
      opt.classList.add('selected');
      selectedMarker = opt.getAttribute('data-marker');
      renderCard();
    });
  });

  // Clear card markings
  btnClear.addEventListener('click', () => {
    cardState = Array(25).fill(false);
    renderCard();
  });

  // New card
  btnNew.addEventListener('click', () => {
    generateCard();
  });

  // Spin the Wheel! host logic
  btnSpin.addEventListener('click', () => {
    if (calledStatements.length >= 25) {
      calledStatementEl.textContent = "All statements called!";
      return;
    }
    let available = cardStatements.filter(s => s !== "FREE" && !calledStatements.includes(s));
    if (available.length === 0) return;
    // Animate spin
    let spinCount = 15;
    let idx = 0;
    btnSpin.disabled = true;
    const spinInterval = setInterval(() => {
      calledStatementEl.textContent = available[idx % available.length];
      idx++;
      spinCount--;
      if (spinCount <= 0) {
        clearInterval(spinInterval);
        let finalStatement = calledStatementEl.textContent;
        calledStatements.push(finalStatement);
        updateHistory();
        btnSpin.disabled = false;
      }
    }, 100);
  });

  // Update history list
  function updateHistory() {
    historyListEl.innerHTML = '';
    calledStatements.forEach((stmt,i) => {
      const li = document.createElement('li');
      li.textContent = `${i+1}. ${stmt}`;
      historyListEl.appendChild(li);
    });
  }

  // Reset full game
  btnResetGame.addEventListener('click', () => {
    calledStatements = [];
    calledStatementEl.textContent = '';
    updateHistory();
    generateCard();
  });

  // Mode toggle buttons logic
  btnPlayer.addEventListener('click', () => toggleMode("player"));
  btnHost.addEventListener('click', () => toggleMode("host"));

  function toggleMode(newMode){
    if(newMode === "player"){
      mode = "player";
      playerPanel.style.display = '';
      hostPanel.style.display = 'none';
      btnPlayer.disabled = true;
      btnHost.disabled = false;
    } else {
      mode = "host";
      playerPanel.style.display = 'none';
      hostPanel.style.display = '';
      btnPlayer.disabled = false;
      btnHost.disabled = true;
    }
  }

  // Initialize
  generateCard();
  toggleMode("player");

</script>
</body>
</html>
